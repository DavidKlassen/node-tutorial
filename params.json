{"name":"Node-tutorial","tagline":"","body":"#Web-разработка на node.js и express\r\n###Изучаем node.js на практике\r\n---\r\n\r\n##Содержание\r\n\r\n* ####[Вступление](#introduction)\r\n\r\n* ####[Глава 1. Старт](#start)\r\n    * [1.1 Рабочее окружение](#environment)\r\n        * [1.1.1 Установка git](#git-install)\r\n        * [1.1.2 Установка node.js и npm](#node-install)\r\n        * [1.1.3 Среда разработки](#ide)\r\n        * [1.1.4 Express и первое приложение](#hello-world)\r\n    * [1.2 Система контроля версий](#version-control)\r\n        * [1.2.1 Настройка git](#git-setup)\r\n        * [1.2.2 Работа с git](#git-workflow)\r\n        * [1.2.3 github](#github)\r\n    * [1.3 Разворачиваем приложение](#deploying)\r\n        * [1.3.1 Настройка Heroku](#heroku-setup)\r\n        * [1.3.2 Разворачиваем приложение](#deploy-hello-world)\r\n\r\n* ####[Глава 2. Статические страницы](#static-pages)\r\n    * [2.1 Model-View-Controller (MVC)](#mvc)\r\n    * [2.2 Демонстрационное приложение](#sample-app)\r\n        * [2.2.1 package.json](#package.json)\r\n        * [2.2.2 Hello, World!](#hello-world)\r\n        * [2.2.3 Структура приложения](#app-structure)\r\n    * [2.3 Тестирование приложения](#tests)\r\n    * [2.4 Статические страницы](#static-pages-sub)\r\n        * [2.4.1 Контроллер статических страниц](#pages-controller)\r\n        * [2.4.2 Шаблонизация и Views](#templates-and-views)\r\n        * [2.4.3 Layout и Twitter Bootstrap](#layout-and-twitter-bootstrap)\r\n        * [2.4.4 Деплой на Heroku](#templates-and-views)\r\n\r\n* ####[Глава 3. Модель пользователя](#user-model)\r\n\r\n---\r\n\r\n##<a name=\"introduction\">Вступление</a>\r\n\r\nПриветствую, перед вами небольшой учебник по практической разработке на node.js, с использованием фреймворка express. Я с большим энтузиазмом отношусь к node и сопутствующим технологиям. Node.js в первую очередь привлекает свежестью в подходах к разработке, смелостью и драйвом.\r\n\r\nО том, что такое node.js вы можете прочитать на [http://nodejs.org/](http://nodejs.org/), если коротко - то это серверная платформа, для выполнения javascript. Так же мы будем использовать express, web-фреймворк построеный на концепции [middleware](http://stephensugden.com/middleware_guide/) (о том, что это такое, поговорим поподробнее чуть позже)\r\n\r\nВ процессе изучения мы познакомимся с различными аспектами web-разработки, такими как использование системы контроля версий, автоматическое тестирование и так далее. В результате по ходу изучения мы разработаем вполне рабочее web-приложение (простенький аналог твиттера)\r\n\r\nХочется отметить, что очень большое влияние на меня оказал [railstutorial](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book), это лучшее пособие по web-разработке, которое я встречал, и мне очень хотелось бы создать нечто подобное для node.js.\r\n\r\n---\r\n\r\n##<a name=\"start\">Глава 1. Старт</a>\r\n\r\nВ этой главе мы развернем рабочее окружение с нуля, установим все необходимые инструменты, создадим простенькое приложение и даже запустим его на облачном хостинге.\r\n\r\n###<a name=\"environment\">1.1 Рабочее окружение</a>\r\n\r\nТак как я в основном использую в работе linux, а если точнее - Ubuntu 12.04, основная часть инструкций по установке тех или иных инструментов будет ориентирована на ползователей линукс, но я буду стараться по возможности давать ссылки на инструкции и для других ОС.\r\n\r\nДля того чтобы точно следовать инструкциям в учебнике, вам нужно будет поставить систему контроля версий [git](http://ru.wikipedia.org/wiki/Git), дело в том, что мы не только будем размещать код своих проектов в git, но и устанавливать многие инструменты из репозиториев на [гитхабе](https://github.com/).\r\n\r\nТак что, первое что мы сделаем - это...\r\n\r\n####<a name=\"git-install\">1.1.1 Установка git</a>\r\n\r\nПользователи apt-based дистрибутивов могут выполнить в терминале:\r\n\r\n    $ sudo apt-get install git-core\r\n\r\nОстальные отправляются читать инструкции по адресу [http://git-scm.com/book/ch1-4.html](http://git-scm.com/book/ch1-4.html)\r\n\r\n####<a name=\"node-install\">1.1.2 Установка node.js и npm</a>\r\n\r\nТеперь пришло время поставить последнюю стабильню версию node.js (на текущий момент это 0.8.1) и npm (установщик пакетов для node). \r\n\r\nИнструкции по установке разных ОС можно найти [здесь](https://github.com/joyent/node/wiki/Installation)\r\n\r\nДля установки на ubuntu выполняем:\r\n\r\n    $ sudo apt-get install python-software-properties\r\n    $ sudo add-apt-repository ppa:chris-lea/node.js\r\n    $ sudo apt-get update\r\n    $ sudo apt-get install nodejs npm\r\n\r\nЕсли есть желание - можно запустить консоль node и поиграться с интерпретатором javascript.\r\n\r\n####<a name=\"ide\">1.1.3 Среда разработки</a>\r\n\r\nТут каждый волен выбирать по своему вкусу, лично меня вполне устраивает gedit с установленным набором плагинов [gmate](https://github.com/gmate/gmate/). Вполне подходят Netbeans или Webstorm.\r\n\r\n####<a name=\"hello-world\">1.1.4 Express и первое приложение</a>\r\n\r\nТеперь пришло время познакомиться с фреймворком [express](http://expressjs.com/). Фреймворк очень простой, и вполне приемлемо документированный. Единственный неудобный момент - это то, что мы будем использовать бета версию 3.0.x а документация на официальном сайте написана для 2.x, так что советую иметь под рукой [migration guide](https://github.com/visionmedia/express/wiki/Migrating-from-2.x-to-3.x)\r\n\r\nУстанавливаем express глобально:\r\n\r\n    $ sudo npm install -g express\r\n\r\nСоздаем директорию для наших учебных проектов:\r\n\r\n    $ mkdir -p ~/projects/node-tutorial\r\n    $ cd ~/projects/node-tutorial\r\n\r\nСоздаем проект и устанавливаем зависимости:\r\n\r\n    $ express first-app\r\n    $ cd first-app && npm install\r\n\r\nЖелающие могут покопаться в том что нам сгенерировал генератор приложений, думаю, что люди знакомые с javascript могут предположить что там происходит.\r\n\r\nТеперь приложение можно запустить:\r\n\r\n    $ node app\r\n\r\nИ увидеть результат работы [http://localhost:3000/](http://localhost:3000/)\r\n\r\n###<a name=\"version-control\">1.2 Система контроля версий</a>\r\n\r\nТеперь, когда у нас уже есть рабочее приложение, более подробно коснемся работы с сисемой контроля версий. Для того чтобы лучше познакомиться с работой git, стоит почитать книжку [Pro Git](http://git-scm.com/book), но можно и обойтись инструкциями в данном учебнике.\r\n\r\n####<a name=\"git-setup\">1.2.1 Настройка git</a>\r\n\r\nДля более комфортной работы с git стоит сначала указать свои личные данные:\r\n\r\n    $ git config --global user.name \"Your Name\"\r\n    $ git config --global user.email your.email@example.com\r\n\r\nИ настроить алиасы для наиболее часто используемых комманд:\r\n\r\n    $ git config --global alias.co checkout\r\n    $ git config --global alias.ci commit\r\n\r\n####<a name=\"git-workflow\">1.2.2 Работа с git</a>\r\n\r\nGit настроен и можно размещать наше приложение в репозитории, инициализируем новый репозиторий:\r\n\r\n    $ git init\r\n\r\nДобавляем директорию с зависимостями приложения в gitignore:\r\n\r\n    $ echo 'node_modules' > .gitignore\r\n\r\nПомещаем все файлы в индекс и создаем первый коммит:\r\n\r\n    $ git add .\r\n    $ git ci -m \"Initial commit\"\r\n\r\n####<a name=\"github\">1.2.3 github</a>\r\n\r\nПосле размещения кода проекта в репозитории пришло время выложить проект на [GitHub](http://github.com/). GitHub - это социальная сеть и хостинг для проектов. Огромное число opensource проектов хостится на гитхабе, так что если вы там еще не зарегистрированы - самое время [сделать это](http://github.com/signup/free). \r\n\r\nПеред тем как работать с GitHub нужно будет создать RSA ключи для доступа по ssh. Процедура описана [тут](https://help.github.com/articles/generating-ssh-keys). Для пользователей linux привожу инструкцию по созданию ключей если их у вас еще нет.\r\n\r\n    $ ssh-keygen -t rsa -C \"your_email@youremail.com\"\r\n\r\nОтвечаем на вопросы генератора, после чего копируем содержимое файла `~/.ssh/id_rsa.pub`:\r\n\r\n    $ sudo apt-get install xclip\r\n    $ xclip -sel clip < ~/.ssh/id_rsa.pub\r\n\r\nПосле этого нужно пройти по ссылке [Account Settings](https://github.com/settings/profile), зайти в раздел SSH Keys и нажать кнопку Add SSH Key и вставить ключ из буфера обмена в поле Key. Затем сохранить.\r\n\r\nПроверить что ключ работает можно так:\r\n\r\n    $ ssh -T git@github.com\r\n\r\nВозможно вы увидете предупреждение:\r\n\r\n    The authenticity of host 'github.com (207.97.227.239)' can't be established.\r\n    # RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\r\n    # Are you sure you want to continue connecting (yes/no)?\r\n\r\nНужно просто ответить 'yes' и тогда, если ключ успешно добавился, вы увидите ответ сервера:\r\n\r\n    Hi username! You've successfully authenticated, but GitHub does not\r\n    # provide shell access.\r\n\r\nКогда ключи настроены [создаем](https://github.com/new) новый репозиторий с названием first-app и дефолтными настройками, после чего выкладываем код на гитхаб:\r\n\r\n    $ git remote add origin git@github.com:ваш_ник_на_гитхабе/first-app.git\r\n    $ git push -u origin master\r\n\r\n###<a name=\"deploying\">1.3 Разворачиваем приложение</a>\r\n\r\nТеперь наступает самый волнующий этап, мы будем разворачивать приложение на хостинге.\r\nДля этого воспользуемся услугами облачной системы деплоя [Heroku](http://www.heroku.com/). Если вам интересно как работает хостинг Heroku, советую поизучать их раздел [How it Works](http://www.heroku.com/how)\r\n\r\n####<a name=\"heroku-setup\">1.3.1 Настройка Heroku</a>\r\n\r\nДля начала нам надо [зарегистрироваться](https://api.heroku.com/signup) и установить необходимый [инструментарий](https://toolbelt.heroku.com/).\r\n\r\nПользователи ubuntu выполняют:\r\n\r\n    $ wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh | sh\r\n\r\nКогда установка завершится, нужно будет залогиниться из коммандной строки:\r\n\r\n    $ heroku login\r\n\r\n####<a name=\"deploy-hello-world\">1.3.2 Размещаем приложение на heroku</a>\r\n\r\nТеперь наше окружение полностью готов к выкладке на хостинг. Размещение node.js проекта на Heroku требует еще нескольких действий, вы можете почитать об этом в [документации](https://devcenter.heroku.com/articles/nodejs) или просто выполнить инструкции.\r\n\r\nВ файле package.json нашего проекта, нужно указать версии ноды и npm, package.json должен выглядеть так:\r\n\r\n    {\r\n      \"name\": \"application-name\",\r\n      \"version\": \"0.0.1\",\r\n      \"private\": true,\r\n      \"scripts\": {\r\n        \"start\": \"node app\"\r\n      },\r\n      \"dependencies\": {\r\n        \"express\": \"3.0.0beta4\",\r\n        \"jade\": \"*\"\r\n      },\r\n      \"engines\": {\r\n        \"node\": \"0.8.x\",\r\n        \"npm\": \"1.1.x\"\r\n      }\r\n    }\r\n\r\nТеперь в корне проекта создаем файл Procfile:\r\n\r\n    $ echo 'web: node app.js'  > Procfile\r\n\r\nПроверяем что все запускается с помощью менеджера процессов:\r\n\r\n    $ foreman start\r\n\r\nПриложение должно быть доступно на [http://localhost:5000/](http://localhost:5000/)\r\n\r\nДобавляем файлы в репозиторий:\r\n    \r\n    $ git add .\r\n    $ git ci -m \"Added Procfile and engines\"\r\n    $ git push\r\n\r\nСоздаем приложение на heroku:\r\n\r\n    $ heroku create\r\n    $ heroku keys:add ~/.ssh/id_rsa.pub\r\n    $ git push heroku master\r\n\r\nНабираем:\r\n\r\n    $ heroku open\r\n\r\nи любуемся задеплоеным приложением.\r\n\r\n---\r\n\r\n##<a name=\"static-pages\">Глава 2. Статические страницы</a>\r\n\r\nВ этой главе мы приступим к разработке нашего приложения, которое мы будем использовать в качестве примера на протяжении всего учебника, и начнем с самого простого, а именно со статических страниц.\r\n\r\n###<a name=\"mvc\">2.1 Model-View-Controller (MVC)</a>\r\n\r\nПеред тем как приступать собственно к разработке приложения, полезно поговорить о том, что из себя представляет типичная архитектура web-приложения на наиболее высоком уровне абстракции. Самым популярным архитектурным паттерном на сегодняшний день является [model-view-controller](http://ссылка.на.википедию) (MVC), общий смысл паттерна заключается в том, чтобы разделить бизнес логику приложения (её привязывают к моделям) и представление - view. Кроме того, модели реализуют интерфейс к базе данных. Контроллер играет роль посредника между моделью и представлением. В случае web-приложения - это выглядит так: браузер пользователя отправляет запрос на сервер, контроллер обрабатывает запрос, получает необходимые данные из модели и отправляет их во view. View получает данные из контроллера и превращает их в красивую HTML страничку, которую контроллер в итоге отправит пользователю.\r\n\r\n![](mvc.jpg)\r\n\r\n###<a name=\"sample-app\">2.2 Демонстрационное приложение</a>\r\n\r\nПришло время приступить к разработке нашего демонстрационного приложения. В первой главе мы уже развернули тестовое приложение, но воспользовались при этом генератором express и не написали ни строчки кода. Теперь мы будем писать наше приложение сами и начнем с \"Hello, World\".\r\n\r\n    $ cd ~/projects/node-tutorial\r\n    $ mkdir node-demo-app\r\n    $ cd node-sample-app\r\n\r\n####<a name=\"package.json\">2.2.1 package.json</a>\r\n\r\nДля того чтобы воспользоваться всеми прелестями, которые нам может предоставить npm (зачем, что это такое  и ссылка), мы создадим в корневой лиректории нашего проекта файлик package.json:\r\n\r\n    {\r\n        \"name\": \"node-demo-app\"\r\n      , \"version\": \"0.0.1\"\r\n      , \"scripts\": {\r\n        \"start\": \"node server.js\"\r\n      }\r\n      , \"dependencies\": {\r\n        \"express\": \"3.0.1\"\r\n      }\r\n    }\r\n\r\nTODO: Описание полей и ссылка на доки по package.json\r\n\r\nТеперь можно выполнить\r\n   \r\n   $ npm install\r\n\r\nВ результате npm создаст директорию node_modules в которую поместит все модули от которых зависит наш проект.\r\n\r\n####<a name=\"hello-world\">2.2.2 Hello, World!</a>\r\n\r\nОсновной файл назовем server.js:\r\n\r\n    var express = require('express')\r\n      , app = express()\r\n      , port = process.env.PORT || 3000\r\n      \r\n    app.get('/', function (req, res) {\r\n      res.send('Hello, World!')\r\n    })\r\n    \r\n    app.listen(port, function () {\r\n      console.log('Listening on port ', port)\r\n    })\r\n\r\nДля того, чтобы полюбоваться результатом нашего труда, есть два способа:\r\n\r\n    $ node server.js\r\n\r\nлибо\r\n\r\n    $ npm start\r\n\r\nВторой способ доступен потому что мы добавили соответствующую строчку в файл конфигурации package.json.\r\n\r\nТеперь по адресу http://localhost:3000/ можно получить строчку 'Hello, World!'.\r\n\r\nНастало время залить что-нибудь в GitHub. Создаем новый репозиторий и выполняем в директории проекта следующий набор комманд, сперва создадим файл README.md (правило хорошего тона)\r\n\r\n    $ echo '# Node.js demo app' > README.md\r\n\r\nСоздадим файл .gitignore для того чтобы не коммитить лишние файлы в git, а именно директорию node_modules:\r\n\r\n    $ echo 'node_modules' > .gitignore\r\n\r\nСоздаем репозиторий, коммитимся и заливаем все на GitHub\r\n\r\n    $ git init\r\n    $ git add .\r\n    $ git commit -m 'Hello, World'\r\n    $ git remote add origin git@github.com:<username>/node-demo-app.git\r\n    $ git push -u origin master\r\n\r\n####<a name=\"app-structure\">2.2.3 Структура приложения</a>\r\n\r\nExpress пока не диктует строгой структуры для файлов приложения, так что мы придумаем свою. Предлагаю такой вариант:\r\n\r\n    /node-demo-app\r\n    |- /controllers   - директория с контроллерами\r\n    |- /models        - модели приложения\r\n    |- /public        - статика - картинки, клиентские скрипты, стили и т.д.\r\n    |- /tests         - автоматические тесты\r\n    |- /views         - html темплейты\r\n    |- app.js         - основной файл приложения\r\n    |- config.js      - файл с настройками приложения\r\n    |- server.js      - http сервер\r\n\r\nДумаю, что для начала этого хватит.\r\n\r\n###<a name=\"tests\">2.3 Тестирование приложения</a>\r\n\r\nО том что такое TDD и зачем нужно писать тесты вы наверняка уже слышали, а если нет, то можете прочитать об этом здесь .... В этом учебнике, для тестирования приложения мы воспользуемся подходом который называется BDD (behavior-driven development). В тестах мы будем описывать предполагаемое поведение приложения. Сами тесты разделим на две категории: integration тесты - они будут имитировать поведение пользователя и тестировать систему целиком, и unit тесты - для тестирования отдельных модулей приложения. В качестве фреймворков мы будем использовать библиотеки Mocha (читается как мокка, кофе-мокка :)), should.js, и supertest. Mocha служит для организации описаний тест-кейсов, should.js предоставляет синтаксис для осуществления различных проверок, а supertest - это надстройка над простеньким http-клиентом, которая позволяет проверять результаты http-запросов. Для подключения библиотек сделаем необходимые изменения в package.json\r\n\r\n    {\r\n        \"name\": \"node-demo-app\"\r\n      , \"version\": \"0.0.1\"\r\n      , \"scripts\": {\r\n        \"start\": \"node server.js\"\r\n      }\r\n      , \"dependencies\": {\r\n          \"express\": \"3.0.1\"\r\n      }\r\n      , \"devDependencies\": {\r\n          \"mocha\": \"1.7.0\"\r\n        , \"should\": \"1.2.1\"\r\n        , \"supertest\": \"0.4.0\"\r\n      }\r\n    }\r\n\r\nЗависимости мы разместили в разделе \"devDependencies\", так как нет никакой необходимости тащить эти библиотеки на продакшн сервер. Для установки библиотек выполняем\r\n\r\n    $ npm install\r\n\r\nДля того что бы понять как это работает, попробуем создать свой первый тест и прогнать его через наш фреймворк\r\n\r\n    $ mkdir tests\r\n    $ touch tests/test.js\r\n\r\nВ test.js положим такой тест\r\n\r\n    describe('Truth', function () {\r\n      it('should be true', function () {\r\n        true.should.be.true\r\n      })\r\n  \r\n      it('should not be false', function () {\r\n        true.should.not.be.false\r\n      })\r\n    })\r\n\r\nи запустим его\r\n\r\n    $ ./node_modules/.bin/mocha --require should --reporter spec tests\r\n\r\nВполне естественно, что такой тест пройдет, так что заменим его на что-то неработающее\r\n\r\n    describe('foo variable', function () {\r\n      it('should equal bar', function () {\r\n        foo.should.equal('bar')\r\n      })\r\n    })\r\n\r\nзапускаем\r\n\r\n    $ ./node_modules/.bin/mocha --require should --reporter spec tests\r\n\r\nи видим, что тесты не прошли, придется чинить код, добавляем объявление переменной\r\n\r\n    var foo = 'bar'\r\n    \r\n    describe('foo variable', function () {\r\n      it('should equal bar', function () {\r\n        foo.should.equal('bar')\r\n      })\r\n    })\r\n\r\nзапускаем\r\n\r\n    $ ./node_modules/.bin/mocha --require should --reporter spec tests\r\n\r\nи видим что код рабочий.\r\n\r\nОсновной принцип TDD состоит в том, чтобы напсать тесты до того как написан код, таким образом мы можем убедиться в том, что тесты действительно что-то тестируют, а не просто запускают код на выполнение и делают проверки в стиле true.should.be.true. То есть процесс разработки выглядит следующим образом:\r\n\r\n1. Пишем тест\r\n2. Выполняем тест и убеждаемся в том что он падает\r\n3. Пишем код\r\n4. Выполняем тест и убеждаемся в том что он проходит, если нет, возвращаемся в п.3\r\n\r\nИ так много раз.\r\n\r\nЧтобы упростить запуск тестов добавим таск прогоняющий тесты в Makefile\r\n\r\n    $ touch Makefile\r\n\r\nСодержимое Makefile:\r\n\r\n    REPORTER=spec\r\n    TESTS=$(shell find ./tests -type f -name \"*.js\")\r\n    \r\n    test:\r\n    \t@./node_modules/.bin/mocha \\\r\n    \t\t--require should \\\r\n    \t\t--reporter $(REPORTER) \\\r\n    \t\t$(TESTS)\r\n    \t\t\r\n    .PHONY: test\r\n\r\nОбращаю внимание на то, что отступы после названия таска должны быть сделаны табами, а не пробелами. Теперь test-suite можно запускать коммандой\r\n\r\n    $ make test\r\n\r\nПопробуем потестировать http запросы. Для того чтобы сделать тестирование более удобным проведем небольшой рефакторинг кода и вынесем приложение express из файла server.js в отдельный модуль app.js\r\n\r\n    $ touch app.js\r\n\r\napp.js:\r\n\r\n    var express = require('express')\r\n      , app = express()\r\n    \r\n    // mount routes\r\n    app.get('/', function (req, res) {\r\n      res.send('Hello, World!')\r\n    })\r\n    \r\n    module.exports = app\r\n\r\nTODO: Написать про систему модулей в node.js\r\n\r\nserver.js заменяем на\r\n\r\n    var app = require(__dirname + '/app')\r\n    \r\n    app.listen(3000, function () {\r\n      console.log('Listening on port ', 3000)\r\n    })\r\n\r\nДля того, чтобы проверить корректность http запроса напишем в test.js следующий код\r\n\r\n    var request = require('supertest')\r\n      , app = require(__dirname + '/../app')\r\n      \r\n    describe('GET /', function () {\r\n      it('should contain text \"Hello, Express!\"', function (done) {\r\n         request(app)\r\n           .get('/')\r\n           .expect(/Hello, Express!/, done)\r\n      })\r\n    })\r\n\r\nВ этом тесте мы проверяем, что сервер отвечает нам строчкой \"Hello, Express!\". Так как вместо этого сервер отвечает \"Hello, World!\", тест упадет. Важный момент, на который нужно обратить внимание, запросы к http серверу происходят асинхронно, по-этому нам нужно будет назначить callback на завешение теста. Mocha предоставляет такую возможность с помощью функции done, которую можно опционально передать в функцию с тест-кейсом. Чтобы тест прошел, нужно заменить строчку \"Hello, World!\" на \"Hello, Express!\" в файле app.js и выполнить `make test`.\r\n\r\nС тестами мы разобрались, так что удаляем тестовый тест\r\n\r\n    $ rm tests/test.js\r\n\r\nИ коммитимся\r\n\r\n    $ git add .\r\n    $ git ci -m \"Added testing framework\"\r\n    $ git push\r\n\r\n###<a name=\"static-pages-sub\">2.4 Статические страницы</a>\r\n\r\nКонечно статические страницы можно сделать по настоящему статическими, то есть разместить файл к примеру index.html со следующим содержанием:\r\n\r\n    <!doctype html>\r\n    <html>\r\n    <head>\r\n      <meta charset=\"utf-8\">\r\n      <title>Hello, World!</title>\r\n    </head>\r\n    <body>\r\n      <h1>Hello, World!</h1>\r\n    </body>\r\n    </html>\r\n\r\nв директории public, и научить приложение отдавать его как статику. Делается это с помощью добавления строчки `app.use(express.static(__dirname + '/public'))` в app.js\r\n\r\n    var express = require('express')\r\n      , app = express()\r\n      \r\n    app.use(express.static(__dirname + '/public'))\r\n      \r\n    app.get('/', function (req, res) {\r\n      res.send('Hello, World!')\r\n    })\r\n    \r\n    module.exports = app\r\n\r\nВсе файлы в директории /public после этого будут отдаваться как статика (http://localhost:3000/index.html). Но нам это не очень интересно, так что стираем ненужный index.html\r\n\r\n    $ rm public/index.html\r\n\r\nи...\r\n\r\n####<a name=\"pages-controller\">2.4.1 Контроллер статических страниц</a>\r\n\r\nРаз уж мы решили придерживаться TDD, то первым делом напишем тест для еще не созданного контроллера pages\r\n\r\n    $ mkdir tests/integration\r\n    $ touch tests/integration/pages.js\r\n\r\npages.js:\r\n\r\n    var request = require('supertest')\r\n      , app = require(__dirname + '/../../app')\r\n      \r\n    describe('Pages', function () {\r\n      describe('GET /', function () {\r\n        it('should redirect to \"home\"', function (done) {\r\n          request(app)\r\n            .get('/')\r\n            .expect('location', '/home')\r\n            .expect(302, done)\r\n        })\r\n      })\r\n      \r\n      describe('GET /home', function () {\r\n        it('should return status code 200', function (done) {\r\n          request(app)\r\n            .get('/home')\r\n            .expect(200, done)\r\n        })\r\n        \r\n        it('should contain text \"Home page\"', function (done) {\r\n          request(app)\r\n            .get('/home')\r\n            .expect(/Home page/, done)\r\n        })\r\n      })\r\n    })\r\n\r\nТут мы описали такие сценарии:\r\n  \r\n  * GET '/' должен редиректить на '/home'\r\n  * GET '/home' должен быть успешным\r\n  * GET '/home' должен в теле ответа содержать строку \"Home page\"\r\n\r\nЗапускаем тесты\r\n\r\n    $ make test\r\n\r\nУбеждаемся в том что они все падают.\r\n\r\nНаша цель в том, чтобы тесты прошли. Создаем контроллер для раздачи статичных страничек:\r\n\r\n    $ mkdir controllers\r\n    $ touch controllers/pages.js\r\n\r\nВ этом контроллере создадим экшн, который будет отдавать нам домашнюю страничку приложения\r\n\r\n    exports.home = function (req, res) {\r\n      res.send('Home page')\r\n    }\r\n\r\nТеперь подключим контроллер страниц, экшн примонтируем к пути '/home', а для пути '/' настроим редирект на '/home' в app.js\r\n\r\n    var express = require('express')\r\n      , app = express()\r\n      , pages = require(__dirname + '/controllers/pages') \r\n      \r\n    // configuration settings \r\n    app.use(express.static(__dirname + '/public'))\r\n    \r\n    // mount routes\r\n    app.get('/', function (req, res) { res.redirect('home') })\r\n    app.get('/home', pages.home)\r\n    \r\n    module.exports = app\r\n\r\nЗапускаем тесты, если мы все сделали правильно, они должны пройти.\r\n\r\n    $ make test\r\n\r\nПри попытке зайти на http://localhost:3000/ нас теперь перекинет на страничку home. С контроллером разобрались, теперь возьмемся за вьюхи.\r\n\r\n####<a name=\"templates-and-views\">2.4.2 Шаблонизация и Views</a>\r\n\r\nExpress в качестве движка дял шаблонизации позоляет подключать разные бибилотеки, такие как ..placeholder.. Мы воспользуемся ejs т.к. как ее синтаксис приближен к html и возможно привычен большинству. Для этого в package.json добавим зависимость \"ejs\": \"0.8.3\"\r\n\r\n    {\r\n        \"name\": \"node-demo-app\"\r\n      , \"version\": \"0.0.1\"\r\n      , \"scripts\": {\r\n        \"start\": \"node server.js\"\r\n      }\r\n      , \"dependencies\": {\r\n          \"express\": \"3.0.1\"\r\n        , \"ejs\": \"0.8.3\"\r\n      }\r\n      , \"devDependencies\": {\r\n          \"mocha\": \"1.7.0\"\r\n        , \"should\": \"1.2.1\"\r\n        , \"supertest\": \"0.4.0\"\r\n      }\r\n    }\r\n\r\nИ выполним\r\n\r\n    $ npm install\r\n\r\nEJS нужно подключить к приложению в app.js\r\n\r\n    var express = require('express')\r\n      , app = express()\r\n      , pages = require(__dirname + '/controllers/pages')\r\n     \r\n    // configuration settings \r\n    app.set('views', __dirname + '/views')\r\n    app.set('view engine', 'ejs')\r\n    app.use(express.static(__dirname + '/public'))\r\n    \r\n    // mount routes\r\n    app.get('/', function (req, res) { res.redirect('home') })\r\n    app.get('/home', pages.home)\r\n    \r\n    module.exports = app\r\n\r\nШаблоны мы будем хранить в директории '/views' с поддиректорией для каждого контроллера и начнем с шаблона для страницы home\r\n\r\n    $ mkdir -p views/pages\r\n    $ touch views/pages/home.ejs\r\n\r\nВ этом файле можно разместить шаблон для странички и использовать переменные, которые туда передаст контроллер, например\r\n\r\n    <!doctype html>\r\n    <html>\r\n    <head>\r\n      <meta charset=\"utf-8\">\r\n      <title><%= title %></title>\r\n    </head>\r\n    <body>\r\n      <h1><%= title %></h1>\r\n      <p><%= message %></p>\r\n    </body>\r\n    </html>\r\n\r\nВ данном случае используются переменные `title` и `message`. И поменяем экшн home в контроллере pages\r\n\r\n    exports.home = function (req, res) {\r\n      res.render('pages/home', {\r\n          title: 'Home page'\r\n        , message: 'This is the \"home\" action of \"pages\" controller'\r\n      })\r\n    }\r\n\r\nНаша \"статическая\" страница стала уже слегка \"динамической\". Любуемся результатом по адресу http://localhost:3000/home\r\n\r\nВ принципе в этот момент было бы неплохо закомититься, предварительно прогнав тесты и убедившись, что наши улучшения ничего не поломали. Вообще это нужно принять за правило, перед коммитом всегда прогоняем test-suite.\r\n\r\n    $ make test\r\n    $ git add .\r\n    $ git ci -m \"Added home page\"\r\n    $ git push\r\n\r\nПредлагаю в качестве упражнения самостоятельно сделать страничку about, добавив необходимый экшн в контроллер pages и создав шаблон для неё. Не забываем примонтировать путь '/about' в app.js. Ну а начать нужно с тестов!\r\n\r\n####<a name=\"layout-and-twitter-bootstrap\">2.4.3 Layout и Twitter Bootstrap</a>\r\n\r\nЕсли у вас получилось создать страницу \"/about\" то теперь у вас две страницы, если не получилось, можете выкачать готовый вариант из гитхаба\r\n\r\n    $ git clone blabla\r\n    $ git checkout blabla\r\n\r\nКак вы могли заметить, в наших вьюшках дублируется код и хотелось бы устранить этот недочет. Для этого создадим layout с базовым каркасом страницы. К сожалению ejs пока что не поддерживает layout-ы, но существует библиотека ejs-locals, которая добавляет этот функционал в шаблонизатор. Подключаем её в проект.\r\n\r\npackage.json:\r\n\r\n    {\r\n        \"name\": \"node-demo-app\"\r\n      , \"version\": \"0.0.1\"\r\n      , \"scripts\": {\r\n        \"start\": \"node server.js\"\r\n      }\r\n      , \"dependencies\": {\r\n          \"express\": \"3.0.1\"\r\n        , \"ejs\": \"0.8.3\"\r\n        , \"ejs-locals\": \"0.2.5\"\r\n      }\r\n      , \"devDependencies\": {\r\n          \"mocha\": \"1.7.0\"\r\n        , \"should\": \"1.2.1\"\r\n        , \"supertest\": \"0.4.0\"\r\n      }\r\n    }\r\n\r\nИнсталируем:\r\n\r\n    $ npm install\r\n\r\nДобавляем в приложение app.js:\r\n\r\n    var express = require('express')\r\n      , ejsLocals = require('ejs-locals')\r\n      , app = express()\r\n      , pages = require(__dirname + '/controllers/pages')\r\n     \r\n    // configuration settings \r\n    app.engine('ejs', ejsLocals)\r\n    app.set('views', __dirname + '/views')\r\n    app.set('view engine', 'ejs')\r\n    app.use(express.static(__dirname + '/public'))\r\n    \r\n    // mount routes\r\n    app.get('/', function (req, res) { res.redirect('home') })\r\n    app.get('/home', pages.home)\r\n    app.get('/about', pages.about)\r\n    \r\n    module.exports = app\r\n\r\nСоздаем layout:\r\n\r\n    $ touch views/layout.ejs\r\n\r\nlayout.ejs:\r\n\r\n    <!doctype html>\r\n    <html>\r\n    <head>\r\n      <meta charset=\"utf-8\">\r\n      <title><%= title %></title>\r\n    </head>\r\n    <body>\r\n      <%- body -%>\r\n    </body>\r\n    </html>\r\n\r\nЭтот файл будет общим каркасом для страниц, а конкретная вьюха будет рендериться на месте тега `<%- body -%>`.\r\n\r\nТеперь можно убрать лишний код из шаблонов home.ejs и about.ejs. Сейчас они идентичны и мы могли бы воспользоваться одним шаблоном для обоих экшнов, но как правило разные страницы имеют разный код так что представим себе, что он различается.\r\n\r\nhome.ejs и about.ejs:\r\n\r\n    <% layout('../layout') -%>\r\n    <h1><%= title %></h1>\r\n    <p><%= message %></p>\r\n\r\nВнешне ничего не должно поменяться, чтобы убедиться в этом запустим tet-suite, а потом закоммитимся\r\n\r\n    $ make test\r\n    $ git add .\r\n    $ git ci -m \"Added layout\"\r\n    $ git push\r\n\r\nОсталось навести красоту, в этом нам поможет фреймворк для прототипирования под названием Twitter Bootstrap, его нужно скачать и положить в /public\r\n\r\n    $ wget http://twitter.github.com/bootstrap/assets/bootstrap.zip\r\n    $ unzip bootstrap.zip -d public/\r\n    $ rm bootstrap.zip\r\n\r\nТеперь воспользуемся шаблоном Bootstrap starter template и сделаем layout на его основе:\r\n\r\nlayout.js:\r\n\r\n    <!doctype html>\r\n    <html>\r\n    <head>\r\n      <meta charset=\"utf-8\">\r\n      <title><%= title %></title>\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <link href=\"bootstrap/css/bootstrap.css\" rel=\"stylesheet\">\r\n      <style>\r\n        body {\r\n          padding-top: 60px;\r\n        }\r\n      </style>\r\n      <link href=\"bootstrap/css/bootstrap-responsive.css\" rel=\"stylesheet\">\r\n    \r\n      <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->\r\n      <!--[if lt IE 9]>\r\n        <script src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"></script>\r\n      <![endif]-->\r\n    </head>\r\n    \r\n    <body>\r\n    \r\n      <div class=\"navbar navbar-inverse navbar-fixed-top\">\r\n        <div class=\"navbar-inner\">\r\n          <div class=\"container\">\r\n            <a class=\"brand\" href=\"/\">Node.js demo app</a>\r\n            <div class=\"nav-collapse collapse\">\r\n              <ul class=\"nav\">\r\n                <li class=\"<%= route == '/home' && 'active' || '' %>\"><a href=\"/home\">Home</a></li>\r\n                <li class=\"<%= route == '/about' && 'active' || '' %>\"><a href=\"/about\">About</a></li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    \r\n      <div class=\"container\">\r\n        <%- body -%>\r\n      </div>\r\n      \r\n      <script src=\"http://code.jquery.com/jquery-latest.js\"></script>\r\n      <script src=\"bootstrap/js/bootstrap.js\"></script>\r\n    </body>\r\n    </html>\r\n\r\nЧтобы добавить в шаблон переменную `route`, которую мы используем для подсветки ссылки на текущую страницу, добавим немножко кода в app.js.\r\n\r\n    var express = require('express')\r\n      , ejsLocals = require('ejs-locals')\r\n      , app = express()\r\n      , pages = require(__dirname + '/controllers/pages')\r\n     \r\n    // configuration settings \r\n    app.engine('ejs', ejsLocals)\r\n    app.set('views', __dirname + '/views')\r\n    app.set('view engine', 'ejs')\r\n    app.use(express.static(__dirname + '/public'))\r\n\r\n    // set view locals\r\n    app.use(function (req, res, next) {\r\n      app.locals.route = req.url\r\n      next()\r\n    })\r\n    \r\n    // mount routes\r\n    app.get('/', function (req, res) { res.redirect('home') })\r\n    app.get('/home', pages.home)\r\n    app.get('/about', pages.about)\r\n    \r\n    module.exports = app\r\n\r\nВыполняем стандартную процедуру:\r\n\r\n    $ make test\r\n    $ git add .\r\n    $ git ci -m \"Added twitter bootstrap\"\r\n    $ git push\r\n\r\nЗапускаем сервер:\r\n\r\n    $ npm start\r\n\r\nЛюбуемся получившейся красотой на http://localhost:3000/.\r\n\r\n####<a name=\"deploy-static-pages\">2.4.4 Деплой на Heroku</a>\r\n\r\nМы уже разворачивали приложение в первой главе, так что просто повторим процесс. Добавляем версии node.js и npm в package.json:\r\n\r\n    {\r\n        \"name\": \"node-demo-app\"\r\n      , \"version\": \"0.0.1\"\r\n      , \"scripts\": { \"start\": \"node server.js\" }\r\n      , \"dependencies\": {\r\n          \"express\": \"3.0.1\"\r\n        , \"ejs\": \"0.8.3\"\r\n        , \"ejs-locals\": \"0.2.5\"\r\n      }\r\n      , \"devDependencies\": {\r\n          \"mocha\": \"1.7.0\"\r\n        , \"should\": \"1.2.1\"\r\n        , \"supertest\": \"0.4.0\"\r\n      }\r\n      , \"engines\": {\r\n          \"node\": \"0.8.x\"\r\n        , \"npm\": \"1.1.x\"\r\n      }\r\n    }\r\n\r\nСоздаем Procfile:\r\n\r\n    $ echo 'web: node server.js'  > Procfile\r\n\r\nОтправляем приложение на heroku:\r\n\r\n    $ heroku create\r\n    $ git push heroku master\r\n    $ heroku open\r\n\r\n---\r\n\r\n##<a name=\"user-model\">Глава 3. Модель пользователя</a>\r\n\r\nSuspendisse hendrerit quam mollis magna pharetra ac convallis justo laoreet. Morbi sit amet malesuada arcu. Sed adipiscing tempus rutrum. Aenean lacinia metus et augue aliquam pulvinar. Praesent nulla ante, ullamcorper vitae varius quis, ullamcorper sit amet risus. Nulla facilisi. Ut risus arcu, convallis a ornare eu, tempor sed elit. Mauris auctor, tellus cursus congue convallis, lorem neque hendrerit turpis, at viverra erat ipsum ut nunc. Fusce non lectus massa, vitae imperdiet lorem. Curabitur dapibus ullamcorper est, ut vestibulum \r\ndiam sollicitudin sit amet. \r\n\r\n---\r\nCopyright David Klassen, 2012. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}